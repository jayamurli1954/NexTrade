# ui/professional_trading_ui.py - FIXED VERSION v3.1.1
# CRITICAL FIX: Added threading to prevent UI freezing
import tkinter as tk
import time
from tkinter import ttk, messagebox, simpledialog
import json
import os
import sys

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# ✅ NEW: Import threading helper
from ui.threading_helper import ThreadManager

class ProfessionalTradingUI:
    def __init__(self, root, analyzer, provider, paper_trader, *, paper_mode=True, **kwargs):
        self.root = root
        self.analyzer = analyzer
        self.provider = provider
        self.paper_trader = paper_trader
        self.paper_mode = paper_mode
        self.settings_password = "1234"

        self.version = kwargs.get("version") or "3.1.1"
        self.build = kwargs.get("build") or "CRITICAL-FIXES"
        self.app_title = kwargs.get("title") or "Angel One Trading Bot"
        self.starting_tab = kwargs.get("starting_tab") or "Dashboard"

        self.max_positions = 5
        self.capital_per_position = 20000

        self._status_text = tk.StringVar(value="Disconnected")
        self._mode_text = tk.StringVar(value="LIVE" if not paper_mode else "PAPER")
        self._connect_text = tk.StringVar(value="Connect")
        self._env_badge_text = tk.StringVar(value="Disconnected (PAPER)" if paper_mode else "Disconnected (LIVE)")
        self._account_name = tk.StringVar(value="")
        self._netcash_text = tk.StringVar(value="₹0.00")

        self.watchlist_file = "data/watchlist.json"
        self.watchlist = self._load_watchlist()

        self.root.wm_title(self.app_title)
        self.root.geometry("1400x900")

        self._configure_styles()
        self._build_header()
        self._build_body()
        self._build_statusbar()

        self.set_connection_status(False, live=not paper_mode)
        self._select_starting_tab()
        self._refresh_dashboard()

        self.root.after(30000, self._auto_refresh)

    def _auto_refresh(self):
        """Auto-refresh with threading - NON-BLOCKING"""
        try:
            # Run refreshes in background
            ThreadManager.run_async(
                func=lambda: self._refresh_dashboard_data(),
                root=self.root
            )
        except Exception as e:
            print(f"Auto-refresh error: {e}")
        finally:
            self.root.after(30000, self._auto_refresh)

    def _build_header(self):
        bar = ttk.Frame(self.root, style="Header.TFrame")
        bar.pack(fill="x", padx=8, pady=6)

        left = ttk.Frame(bar, style="Header.TFrame")
        left.pack(side="left")

        right = ttk.Frame(bar, style="Header.TFrame")
        right.pack(side="right")

        ttk.Label(left, textvariable=self._env_badge_text, style="EnvBadge.TLabel").pack(side="left", padx=(0, 10))
        ttk.Label(left, textvariable=self._status_text, style="TLabel").pack(side="left")

        self.btn_panic = ttk.Button(right, text="EMERGENCY STOP", command=self._panic_pressed, style="Danger.TButton")
        self.btn_panic.pack(side="left", padx=6)

        ttk.Button(right, text="Settings", command=self._open_settings_with_password).pack(side="left", padx=6)

        self.btn_connect = ttk.Button(right, textvariable=self._connect_text, command=self._toggle_connect, style="Success.TButton")
        self.btn_connect.pack(side="left", padx=6)

        ttk.Label(right, textvariable=self._mode_text, style="ModePill.TLabel").pack(side="left", padx=(12, 0))

    def _build_body(self):
        self.notebook = ttk.Notebook(self.root)
        self.notebook.pack(fill="both", expand=True)

        self.tab_dashboard = ttk.Frame(self.notebook)
        self.tab_portfolio = ttk.Frame(self.notebook)
        self.tab_premarket = ttk.Frame(self.notebook)
        self.tab_watchlist = ttk.Frame(self.notebook)
        self.tab_analyzer = ttk.Frame(self.notebook)
        self.tab_paper = ttk.Frame(self.notebook)
        self.tab_logs = ttk.Frame(self.notebook)
        self.tab_about = ttk.Frame(self.notebook)

        self.notebook.add(self.tab_dashboard, text="Dashboard")
        self.notebook.add(self.tab_portfolio, text="Portfolio")
        self.notebook.add(self.tab_premarket, text="Pre-Market")
        self.notebook.add(self.tab_watchlist, text="Watchlist")
        self.notebook.add(self.tab_analyzer, text="Analyzer")
        self.notebook.add(self.tab_paper, text="Paper Trade")
        self.notebook.add(self.tab_logs, text="Logs")
        self.notebook.add(self.tab_about, text="About")

        self._build_dashboard_tab(self.tab_dashboard)
        self._build_portfolio_tab(self.tab_portfolio)
        self._build_premarket_tab(self.tab_premarket)
        self._build_watchlist_tab(self.tab_watchlist)
        self._build_analyzer_tab(self.tab_analyzer)
        self._build_paper_tab(self.tab_paper)
        self._build_logs_tab(self.tab_logs)
        self._build_about_tab(self.tab_about)

    def _build_statusbar(self):
        bar = ttk.Frame(self.root, style="Statusbar.TFrame")
        bar.pack(fill="x", side="bottom")
        ttk.Label(bar, text=f"{self.app_title} v{self.version} {self.build}".strip(), style="Status.TLabel").pack(side="left", padx=8)

    def _build_dashboard_tab(self, parent):
        wrap = ttk.Frame(parent)
        wrap.pack(fill="both", expand=True, padx=12, pady=12)

        top = ttk.Frame(wrap)
        top.pack(fill="x", pady=(0, 10))
        ttk.Label(top, text="Account:", style="Heading.TLabel").pack(side="left")
        ttk.Label(top, textvariable=self._account_name).pack(side="left", padx=(6, 16))
        ttk.Label(top, text="Available Margin:", style="Heading.TLabel").pack(side="left")
        ttk.Label(top, textvariable=self._netcash_text).pack(side="left", padx=6)
        ttk.Button(top, text="Refresh Now", command=self._refresh_dashboard).pack(side="right")

        left = ttk.Frame(wrap)
        left.pack(side="left", fill="both", expand=True, padx=(0, 6))
        ttk.Label(left, text="Provider Snapshot", style="Heading.TLabel").pack(anchor="w")
        self._provider_text = tk.Text(left, height=18, wrap="word", font=("Consolas", 9))
        self._provider_text.pack(fill="both", expand=True, pady=(6, 0))

        right = ttk.Frame(wrap)
        right.pack(side="right", fill="both", expand=True, padx=(6, 0))
        ttk.Label(right, text="Holdings & Positions", style="Heading.TLabel").pack(anchor="w")
        self._holdings_text = tk.Text(right, height=18, wrap="word", font=("Consolas", 9))
        self._holdings_text.pack(fill="both", expand=True, pady=(6, 0))

    def _build_portfolio_tab(self, parent):
        """Build portfolio holdings tab"""
        box = ttk.Frame(parent)
        box.pack(fill="both", expand=True, padx=12, pady=12)

        header = ttk.Frame(box)
        header.pack(fill="x", pady=(0, 8))
        ttk.Label(header, text="Real Broker Holdings from Angel One", style="Heading.TLabel").pack(side="left")
        ttk.Button(header, text="Refresh Holdings", command=self._refresh_portfolio, style="Success.TButton").pack(side="right")

        self._portfolio_summary = ttk.Label(box, text="", font=("Segoe UI", 10))
        self._portfolio_summary.pack(anchor="w", pady=(0, 8))

        columns = ('symbol', 'qty', 'avg_price', 'current_price', 'pnl', 'pnl_pct')
        self.holdings_tree = ttk.Treeview(box, columns=columns, show='headings', height=20)
        
        self.holdings_tree.heading('symbol', text='Symbol')
        self.holdings_tree.heading('qty', text='Quantity')
        self.holdings_tree.heading('avg_price', text='Avg Price')
        self.holdings_tree.heading('current_price', text='Current Price')
        self.holdings_tree.heading('pnl', text='P&L (₹)')
        self.holdings_tree.heading('pnl_pct', text='P&L %')
        
        self.holdings_tree.column('symbol', width=150)
        self.holdings_tree.column('qty', width=100)
        self.holdings_tree.column('avg_price', width=120)
        self.holdings_tree.column('current_price', width=120)
        self.holdings_tree.column('pnl', width=150)
        self.holdings_tree.column('pnl_pct', width=100)
        
        self.holdings_tree.pack(fill="both", expand=True)
        
        self.holdings_tree.tag_configure('profit', background='#d4edda')
        self.holdings_tree.tag_configure('loss', background='#f8d7da')
        
        self._refresh_portfolio()

    def _refresh_portfolio(self):
        """✅ FIXED: Refresh portfolio - NON-BLOCKING with threading"""
        for item in self.holdings_tree.get_children():
            self.holdings_tree.delete(item)
        
        if not self.provider.is_connected:
            self._portfolio_summary.config(text="Not connected to broker")
            return
        
        self._portfolio_summary.config(text="⏳ Loading holdings...")
        
        def fetch_holdings():
            return self.provider.get_holdings()
        
        def on_success(holdings):
            total_pnl = 0
            total_value = 0
            
            for h in holdings:
                pnl = h['pnl']
                total_pnl += pnl
                total_value += h['current_price'] * h['quantity']
                
                tag = 'profit' if pnl >= 0 else 'loss'
                self.holdings_tree.insert('', 'end', values=(
                    h['symbol'],
                    h['quantity'],
                    f"₹{h['avg_price']:.2f}",
                    f"₹{h['current_price']:.2f}",
                    f"₹{pnl:.2f}",
                    f"{h['pnl_percent']:+.2f}%"
                ), tags=(tag,))
            
            summary_text = f"Total Holdings: {len(holdings)} | Portfolio Value: ₹{total_value:,.2f} | Total P&L: ₹{total_pnl:+,.2f}"
            self._portfolio_summary.config(text=summary_text)
        
        def on_error(error):
            self._portfolio_summary.config(text=f"Error: {error}")
        
        # ✅ Execute in background - UI stays responsive!
        ThreadManager.run_async(
            func=fetch_holdings,
            on_success=on_success,
            on_error=on_error,
            root=self.root
        )

    def _build_premarket_tab(self, parent):
        box = ttk.Frame(parent)
        box.pack(fill="both", expand=True, padx=12, pady=12)

        header = ttk.Frame(box)
        header.pack(fill="x", pady=(0, 8))
        ttk.Label(header, text="Pre-Market Analysis (7:00 AM - 9:15 AM)", style="Heading.TLabel").pack(side="left")
        ttk.Button(header, text="Run Pre-Market Scan", command=self._run_premarket_analysis, style="Success.TButton").pack(side="right")

        self._premarket_info = tk.Text(box, height=4, wrap="word", bg="#f0f0f0", font=("Consolas", 9))
        self._premarket_info.pack(fill="x", pady=(0, 8))

        columns = ('symbol', 'action', 'confidence', 'price', 'qty', 'target', 'sl', 'reason')
        self.premarket_tree = ttk.Treeview(box, columns=columns, show='headings', height=15)
        for col in columns:
            self.premarket_tree.heading(col, text=col.replace('_', ' ').title())
        
        self.premarket_tree.column('symbol', width=80)
        self.premarket_tree.column('action', width=60)
        self.premarket_tree.column('confidence', width=90)
        self.premarket_tree.column('price', width=100)
        self.premarket_tree.column('qty', width=60)
        self.premarket_tree.column('target', width=100)
        self.premarket_tree.column('sl', width=100)
        self.premarket_tree.column('reason', width=350)
        
        self.premarket_tree.pack(fill="both", expand=True, pady=(0, 8))

        btn_frame = ttk.Frame(box)
        btn_frame.pack(fill="x")
        ttk.Button(btn_frame, text="Execute Selected Trade", command=lambda: self._execute_trade_from_tree(self.premarket_tree), style="Success.TButton").pack(side="left", padx=4)

    def _run_premarket_analysis(self):
        """✅ FIXED: Run pre-market analysis - NON-BLOCKING"""
        self._premarket_info.delete("1.0", "end")
        self._premarket_info.insert("1.0", "⏳ Running pre-market analysis...")
        
        def analyze():
            return self.analyzer.run_premarket_analysis(self.watchlist)
        
        def on_success(result):
            info_text = f"""Timestamp: {result['timestamp']}
Market Hours: {'YES - Pre-Market Active' if result['is_premarket_hours'] else 'NO - Outside Hours'}
Analyzed: {result['total_symbols_analyzed']} | Signals: {result['signals_found']} | High Confidence: {result['high_confidence_signals']}"""
            self._premarket_info.delete("1.0", "end")
            self._premarket_info.insert("1.0", info_text)
            
            for item in self.premarket_tree.get_children():
                self.premarket_tree.delete(item)
            
            # ✅ Sort by confidence (descending) and take top 10
            sorted_signals = sorted(result['signals'], key=lambda x: x.get('confidence', 0), reverse=True)
            top_signals = sorted_signals[:10]
            
            # Update info text to show filtered count
            total_found = len(result['signals'])
            showing_count = len(top_signals)
            for sig in top_signals:
                qty = self._calculate_quantity(sig['current_price'])
                self.premarket_tree.insert('', 'end', values=(
                    sig['symbol'],
                    sig['action'],
                    f"{sig['confidence']:.1%}",
                    f"₹{sig['current_price']:.2f}",
                    qty,
                    f"₹{sig['target']:.2f}",
                    f"₹{sig['stop_loss']:.2f}",
                    sig['reason'][:50]
                ), tags=(sig['action'],))
            
            self.premarket_tree.tag_configure('BUY', background='#d4edda')
            self.premarket_tree.tag_configure('SELL', background='#f8d7da')
            
            messagebox.showinfo("Success", f"Found {result['signals_found']} signals")
        
        def on_error(error):
            self._premarket_info.delete("1.0", "end")
            self._premarket_info.insert("1.0", f"Error: {error}")
            messagebox.showerror("Error", f"Pre-market analysis failed: {str(error)}")
        
        # ✅ Execute in background
        ThreadManager.run_async(
            func=analyze,
            on_success=on_success,
            on_error=on_error,
            root=self.root
        )

    def _calculate_quantity(self, price):
        """Calculate quantity based on capital allocation and leverage"""
        capital_with_leverage = self.capital_per_position * self.paper_trader.leverage
        qty = int(capital_with_leverage / price)
        return max(1, qty)

    def _build_watchlist_tab(self, parent):
        box = ttk.Frame(parent)
        box.pack(fill="both", expand=True, padx=12, pady=12)

        ttk.Label(box, text="Watchlist - Monitor Live Prices", style="Heading.TLabel").pack(anchor="w", pady=(0, 8))

        self.watchlist_list = tk.Listbox(box, height=15, font=("Consolas", 10))
        self.watchlist_list.pack(fill="both", expand=True)
        self._update_watchlist_display()

        controls = ttk.Frame(box)
        controls.pack(fill="x", pady=8)

        ttk.Label(controls, text="Add Symbol:").pack(side="left", padx=(0, 6))
        self.add_entry = ttk.Entry(controls, width=20)
        self.add_entry.pack(side="left")
        self.add_entry.bind('<Return>', lambda e: self._add_to_watchlist())

        ttk.Button(controls, text="Add", command=self._add_to_watchlist).pack(side="left", padx=6)
        ttk.Button(controls, text="Remove", command=self._remove_from_watchlist).pack(side="left", padx=6)
        ttk.Button(controls, text="Refresh LTP", command=self._update_watchlist_display).pack(side="left", padx=6)

    def _load_watchlist(self):
        if os.path.exists(self.watchlist_file):
            try:
                with open(self.watchlist_file, 'r') as f:
                    return json.load(f)
            except:
                pass
        return ["RELIANCE", "INFY", "TCS", "HDFCBANK", "ICICIBANK", "SBIN"]

    def _save_watchlist(self):
        os.makedirs(os.path.dirname(self.watchlist_file), exist_ok=True)
        with open(self.watchlist_file, 'w') as f:
            json.dump(self.watchlist, f)

    def _update_watchlist_display(self):
        """Update watchlist display - FIXED: Only updates prices, doesn't rebuild list"""
        
        # Get current number of items
        current_count = self.watchlist_list.size()
        
        # If count changed, rebuild the list
        if current_count != len(self.watchlist):
            self.watchlist_list.delete(0, tk.END)
            for idx, sym in enumerate(self.watchlist):
                self.watchlist_list.insert(tk.END, f"{sym:12} | LTP: Fetching...")

                # ✅ Rate limiting: prevent API access denied
                time.sleep(0.5)  # 500ms delay = max 2 requests/sec
        
        # Now just update the prices without rebuilding
        for idx, sym in enumerate(self.watchlist):
            try:
                ltp = self.provider.get_ltp(sym, 'NSE')
                display = f"{sym:12} | LTP: ₹{ltp:8.2f}" if ltp else f"{sym:12} | LTP: N/A"
                
                # Update only if text changed (prevents flickering)
                if idx < self.watchlist_list.size():
                    current_text = self.watchlist_list.get(idx)
                    if current_text != display:
                        self.watchlist_list.delete(idx)

                # ✅ Rate limiting for watchlist
                if idx < len(self.watchlist) - 1:
                    time.sleep(0.5)  # 500ms delay
                        self.watchlist_list.insert(idx, display)
            except Exception as e:
                # If error, just show N/A
                display = f"{sym:12} | LTP: N/A"
                if idx < self.watchlist_list.size():
                    self.watchlist_list.delete(idx)
                    self.watchlist_list.insert(idx, display)

    def _add_to_watchlist(self):
        sym = self.add_entry.get().strip().upper()
        if sym and sym not in self.watchlist:
            self.watchlist.append(sym)
            self._save_watchlist()
            self._update_watchlist_display()
        self.add_entry.delete(0, tk.END)

    def _remove_from_watchlist(self):
        selected = self.watchlist_list.curselection()
        if selected:
            del self.watchlist[selected[0]]
            self._save_watchlist()
            self._update_watchlist_display()

    def _build_analyzer_tab(self, parent):
        box = ttk.Frame(parent)
        box.pack(fill="both", expand=True, padx=12, pady=12)

        header = ttk.Frame(box)
        header.pack(fill="x", pady=(0, 8))
        ttk.Label(header, text="Golden Ratio Signal Analyzer", style="Heading.TLabel").pack(side="left")
        ttk.Button(header, text="Run Analysis", command=self._run_analysis, style="Success.TButton").pack(side="right")

        self._analyzer_info = tk.Text(box, height=3, wrap="word", bg="#f0f0f0", font=("Consolas", 9))
        self._analyzer_info.pack(fill="x", pady=(0, 8))

        columns = ('symbol', 'action', 'confidence', 'price', 'qty', 'target', 'stop_loss', 'reason')
        self.signal_tree = ttk.Treeview(box, columns=columns, show='headings', height=15)
        for col in columns:
            self.signal_tree.heading(col, text=col.replace('_', ' ').title())
        
        self.signal_tree.column('symbol', width=80)
        self.signal_tree.column('action', width=60)
        self.signal_tree.column('confidence', width=90)
        self.signal_tree.column('price', width=100)
        self.signal_tree.column('qty', width=60)
        self.signal_tree.column('target', width=100)
        self.signal_tree.column('stop_loss', width=100)
        self.signal_tree.column('reason', width=350)
        
        self.signal_tree.pack(fill="both", expand=True, pady=(0, 8))

        btn_frame = ttk.Frame(box)
        btn_frame.pack(fill="x")
        ttk.Button(btn_frame, text="Execute Selected Trade", command=lambda: self._execute_trade_from_tree(self.signal_tree), style="Success.TButton").pack(side="left")

    def _run_analysis(self):
        """✅ FIXED: Run analyzer - NON-BLOCKING"""
        from datetime import datetime
        
        self._analyzer_info.delete("1.0", "end")
        self._analyzer_info.insert("1.0", "⏳ Analyzing watchlist...")
        
        def analyze():
            return self.analyzer.analyze_watchlist(self.watchlist)
        
        def on_success(signals):
            high_conf = sum(1 for s in signals if s.get('confidence', 0) > 0.7)
            info_text = f"""Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Analyzed: {len(self.watchlist)} | Signals Found: {len(top_signals)} of {len(signals)} | High Confidence: {high_conf}"""
            self._analyzer_info.delete("1.0", "end")
            self._analyzer_info.insert("1.0", info_text)
            
            for item in self.signal_tree.get_children():
                self.signal_tree.delete(item)
            
            # ✅ Sort by confidence and take top 10
            sorted_signals = sorted(signals, key=lambda x: x.get('confidence', 0), reverse=True)
            top_signals = sorted_signals[:10]
            
            for sig in top_signals:
                qty = self._calculate_quantity(sig['current_price'])
                self.signal_tree.insert('', 'end', values=(
                    sig['symbol'],
                    sig['action'],
                    f"{sig['confidence']:.1%}",
                    f"₹{sig['current_price']:.2f}",
                    qty,
                    f"₹{sig['target']:.2f}",
                    f"₹{sig['stop_loss']:.2f}",
                    sig['reason'][:50]
                ), tags=(sig['action'],))
            
            self.signal_tree.tag_configure('BUY', background='#d4edda')
            self.signal_tree.tag_configure('SELL', background='#f8d7da')
            
            messagebox.showinfo("Success", f"Analysis complete. Found {len(signals)} signals.")
        
        def on_error(error):
            self._analyzer_info.delete("1.0", "end")
            self._analyzer_info.insert("1.0", f"Error: {error}")
            messagebox.showerror("Error", f"Analysis failed: {str(error)}")
        
        # ✅ Execute in background
        ThreadManager.run_async(
            func=analyze,
            on_success=on_success,
            on_error=on_error,
            root=self.root
        )

    def _execute_trade_from_tree(self, tree):
        """Execute trade with calculated quantity"""
        selection = tree.selection()
        if not selection:
            messagebox.showwarning("No Selection", "Please select a signal")
            return
        
        item = tree.item(selection[0])
        values = item['values']
        
        symbol = str(values[0])
        action = str(values[1])
        price_str = str(values[3]).replace('₹', '').strip()
        qty = int(values[4])
        target_str = str(values[5]).replace('₹', '').strip()
        sl_str = str(values[6]).replace('₹', '').strip()
        
        try:
            current_price = float(price_str)
            target = float(target_str)
            sl = float(sl_str)
            
            if action == 'BUY':
                success, msg = self.paper_trader.buy(symbol, qty, current_price, sl, target)
            elif action == 'SELL':
                success, msg = self.paper_trader.sell(symbol, qty, current_price)
            else:
                messagebox.showwarning("Invalid", f"Unknown action: {action}")
                return
            
            if success:
                messagebox.showinfo("Success", f"{action}: {msg}")
                self._refresh_paper_tab()
                self._refresh_dashboard()
            else:
                messagebox.showerror("Failed", msg)
        except Exception as e:
            messagebox.showerror("Error", f"Trade execution failed: {str(e)}")

    def _build_paper_tab(self, parent):
        box = ttk.Frame(parent)
        box.pack(fill="both", expand=True, padx=12, pady=12)

        header = ttk.Frame(box)
        header.pack(fill="x", pady=(0, 8))
        ttk.Label(header, text="Paper Trading Positions", style="Heading.TLabel").pack(side="left")
        ttk.Button(header, text="Refresh", command=self._refresh_paper_tab).pack(side="right", padx=4)
        ttk.Button(header, text="Square Off All", command=self._square_off_all, style="Danger.TButton").pack(side="right")

        summary = ttk.Frame(box)
        summary.pack(fill="x", pady=(0, 8))
        
        self._paper_summary_label = ttk.Label(summary, text="", font=("Segoe UI", 10))
        self._paper_summary_label.pack(anchor="w")

        columns = ('symbol', 'qty', 'avg_price', 'current_price', 'pnl', 'pnl_pct', 'action')
        self.position_tree = ttk.Treeview(box, columns=columns, show='headings', height=15)
        
        self.position_tree.heading('symbol', text='Symbol')
        self.position_tree.heading('qty', text='Qty')
        self.position_tree.heading('avg_price', text='Avg Price')
        self.position_tree.heading('current_price', text='Live Price')
        self.position_tree.heading('pnl', text='P&L (₹)')
        self.position_tree.heading('pnl_pct', text='P&L %')
        self.position_tree.heading('action', text='Action')
        
        self.position_tree.column('symbol', width=100)
        self.position_tree.column('qty', width=80)
        self.position_tree.column('avg_price', width=120)
        self.position_tree.column('current_price', width=120)
        self.position_tree.column('pnl', width=120)
        self.position_tree.column('pnl_pct', width=100)
        self.position_tree.column('action', width=100)
        
        self.position_tree.pack(fill="both", expand=True)
        self.position_tree.bind('<Button-1>', self._on_position_click)
        
        self._refresh_paper_tab()

    def _on_position_click(self, event):
        """Handle clicks on position tree"""
        region = self.position_tree.identify("region", event.x, event.y)
        if region == "cell":
            column = self.position_tree.identify_column(event.x)
            if column == '#7':
                item = self.position_tree.identify_row(event.y)
                if item:
                    values = self.position_tree.item(item)['values']
                    symbol = values[0]
                    if messagebox.askyesno("Exit Position", f"Exit position in {symbol}?"):
                        self._exit_position(symbol)

    def _exit_position(self, symbol):
        """✅ FIXED: Manually exit with proper price validation"""
        holdings = self.paper_trader.holdings_snapshot()
        if symbol in holdings['positions']:
            pos = holdings['positions'][symbol]
            
            # ✅ FIX: Use retry logic instead of fallback
            current_price = self.paper_trader._get_live_price_with_retry(symbol)
            
            if current_price is None:
                messagebox.showerror("Error", 
                    f"Cannot exit {symbol} - failed to fetch live price after retries.\n\n"
                    "Please try again in a few seconds.")
                return
            
            success, msg = self.paper_trader.sell(symbol, pos['qty'], current_price)
            if success:
                messagebox.showinfo("Success", f"Exited {symbol}: {msg}")
                self._refresh_paper_tab()
                self._refresh_dashboard()
            else:
                messagebox.showerror("Failed", msg)

    def _refresh_paper_tab(self):
        """Refresh paper trading positions"""
        for item in self.position_tree.get_children():
            self.position_tree.delete(item)
        
        holdings = self.paper_trader.holdings_snapshot()
        total_pnl = 0
        
        for sym, pos in holdings.get('positions', {}).items():
            current_price = self.provider.get_ltp(sym, 'NSE') or pos['avg_price']
            pnl = (current_price - pos['avg_price']) * pos['qty']
            pnl_pct = ((current_price / pos['avg_price']) - 1) * 100
            total_pnl += pnl
            
            tag = 'profit' if pnl > 0 else 'loss'
            self.position_tree.insert('', 'end', values=(
                sym,
                pos['qty'],
                f"₹{pos['avg_price']:.2f}",
                f"₹{current_price:.2f}",
                f"₹{pnl:.2f}",
                f"{pnl_pct:+.2f}%",
                "Exit"
            ), tags=(tag,))
        
        self.position_tree.tag_configure('profit', background='#d4edda')
        self.position_tree.tag_configure('loss', background='#f8d7da')
        
        summary_text = f"Total Positions: {holdings['total_positions']} | Cash: ₹{holdings['cash']:,.2f} | Used Margin: ₹{holdings['used_margin']:,.2f} | Available: ₹{holdings['available_margin']:,.2f} | Total P&L: ₹{total_pnl:+,.2f}"
        self._paper_summary_label.config(text=summary_text)

    def _square_off_all(self):
        if messagebox.askyesno("Confirm", "Square off all positions immediately?"):
            self.paper_trader.square_off_all(self.provider)
            self._refresh_paper_tab()
            self._refresh_dashboard()
            messagebox.showinfo("Done", "All positions squared off")

    def _build_logs_tab(self, parent):
        box = ttk.Frame(parent)
        box.pack(fill="both", expand=True, padx=12, pady=12)
        
        header = ttk.Frame(box)
        header.pack(fill="x", pady=(0, 8))
        ttk.Label(header, text="Application Logs", style="Heading.TLabel").pack(side="left")
        ttk.Button(header, text="Refresh Logs", command=self._refresh_logs).pack(side="right")
        
        self.logs_text = tk.Text(box, height=25, wrap="word", font=("Consolas", 9))
        self.logs_text.pack(fill="both", expand=True)
        
        self._refresh_logs()

    def _refresh_logs(self):
        try:
            log_file = 'logs/app.log'
            if os.path.exists(log_file):
                with open(log_file, 'r') as f:
                    logs = f.readlines()[-150:]
                self.logs_text.delete("1.0", "end")
                self.logs_text.insert("end", ''.join(logs))
                self.logs_text.see("end")
            else:
                self.logs_text.insert("end", "No logs found.")
        except Exception as e:
            self.logs_text.insert("end", f"Error loading logs: {e}")

    def _build_about_tab(self, parent):
        box = ttk.Frame(parent)
        box.pack(fill="both", expand=True, padx=20, pady=20)
        
        about_text = f"""ANGEL ONE TRADING BOT - CRITICAL FIXES v3.1.1

Version: {self.version} | Build: {self.build}

✅ FIXED IN THIS VERSION:
• NO MORE UI FREEZING - All operations run in background threads
• NO MORE ₹1000 EXIT ERRORS - Price validation implemented
• Real-time SL/Target monitoring every 10 seconds
• Proper retry logic with exponential backoff
• Excel logging with all trade details

Features:
• Golden Ratio Analysis (Fibonacci + RSI + EMA + Bollinger Bands)
• Pre-Market Analyzer (7:00 AM - 9:15 AM)
• Live Angel One API Integration
• Enhanced Paper Trading with P&L tracking & Margin calculation
• Auto Stop-Loss & Target execution
• Dynamic Quantity calculation based on risk management
• Password-protected settings

Mode: {'PAPER TRADING' if self.paper_mode else 'LIVE TRADING'}

Trading Parameters:
• Max Positions: {self.max_positions}
• Capital per Position: ₹{self.capital_per_position:,}
• Leverage: {self.paper_trader.leverage}x

Warning: This is educational software. Always test thoroughly in paper mode before live trading."""
        
        ttk.Label(box, text=about_text, justify="left", font=("Segoe UI", 10)).pack(anchor="w")

    def _configure_styles(self):
        style = ttk.Style()
        try:
            style.theme_use("clam")
        except:
            pass

        style.configure("Header.TFrame", background="#ecf0f1")
        style.configure("Statusbar.TFrame", background="#ecf0f1")
        style.configure("Heading.TLabel", font=("Segoe UI", 11, "bold"))
        style.configure("Status.TLabel", foreground="#7f8c8d")
        style.configure("EnvBadge.TLabel", padding=6, background="#1abc9c", foreground="white", font=("Segoe UI", 9, "bold"))
        style.configure("ModePill.TLabel", padding=(10, 4), background="#2c3e50", foreground="white", font=("Segoe UI", 9, "bold"))
        
        style.configure("Danger.TButton", padding=8)
        style.configure("Success.TButton", padding=8)

    def set_connection_status(self, connected: bool, *, live: bool):
        if connected:
            self._status_text.set("Connected")
            self._connect_text.set("Disconnect")
            mode_text = "LIVE" if live else "PAPER"
            self._env_badge_text.set(f"Connected ({mode_text})")
        else:
            self._status_text.set("Disconnected")
            self._connect_text.set("Connect")
            mode_text = "LIVE" if live else "PAPER"
            self._env_badge_text.set(f"Disconnected ({mode_text})")

    def _select_starting_tab(self):
        tabs = {"Dashboard": 0, "Portfolio": 1, "Pre-Market": 2, "Watchlist": 3, "Analyzer": 4, "Paper Trade": 5, "Logs": 6, "About": 7}
        idx = tabs.get(self.starting_tab, 0)
        self.notebook.select(idx)

    def _panic_pressed(self):
        """EMERGENCY STOP - Squares off all positions immediately"""
        if messagebox.askyesno("EMERGENCY STOP", "This will IMMEDIATELY square off ALL positions. Continue?"):
            self.paper_trader.square_off_all(self.provider)
            self._refresh_paper_tab()
            self._refresh_dashboard()
            messagebox.showwarning("EMERGENCY STOP", "All positions have been squared off!")

    def _open_settings_with_password(self):
        """Open settings with password protection"""
        password = simpledialog.askstring("Password Required", "Enter settings password:", show='*')
        if password == self.settings_password:
            self._open_settings()
        else:
            messagebox.showerror("Access Denied", "Incorrect password!")

    def _open_settings(self):
        settings_win = tk.Toplevel(self.root)
        settings_win.title("Angel One Settings")
        settings_win.geometry("500x450")

        ttk.Label(settings_win, text="Angel One Credentials", font=("Segoe UI", 12, "bold")).pack(pady=10)

        frame = ttk.Frame(settings_win)
        frame.pack(fill="both", expand=True, padx=20, pady=10)

        ttk.Label(frame, text="API Key:").grid(row=0, column=0, sticky="w", pady=5)
        api_key = ttk.Entry(frame, width=35)
        api_key.grid(row=0, column=1, pady=5)
        api_key.insert(0, self.provider.api_key or "")

        ttk.Label(frame, text="Client Code:").grid(row=1, column=0, sticky="w", pady=5)
        client_code = ttk.Entry(frame, width=35)
        client_code.grid(row=1, column=1, pady=5)
        client_code.insert(0, self.provider.client_code or "")

        ttk.Label(frame, text="Password:").grid(row=2, column=0, sticky="w", pady=5)
        password = ttk.Entry(frame, width=35, show="*")
        password.grid(row=2, column=1, pady=5)
        password.insert(0, self.provider.password or "")

        ttk.Label(frame, text="TOTP Secret:").grid(row=3, column=0, sticky="w", pady=5)
        totp_secret = ttk.Entry(frame, width=35)
        totp_secret.grid(row=3, column=1, pady=5)
        totp_secret.insert(0, self.provider.totp_secret or "")

        ttk.Label(frame, text="Get from Angel One app", font=("Segoe UI", 8), foreground="gray").grid(row=4, column=1, sticky="w")

        ttk.Separator(settings_win, orient='horizontal').pack(fill='x', pady=10)

        ttk.Label(settings_win, text="Trading Parameters", font=("Segoe UI", 11, "bold")).pack(pady=5)
        
        params_frame = ttk.Frame(settings_win)
        params_frame.pack(fill="x", padx=20, pady=5)

        ttk.Label(params_frame, text="Max Positions:").grid(row=0, column=0, sticky="w", pady=5)
        max_pos = ttk.Entry(params_frame, width=10)
        max_pos.grid(row=0, column=1, pady=5, sticky="w")
        max_pos.insert(0, str(self.max_positions))

        ttk.Label(params_frame, text="Capital per Position:").grid(row=1, column=0, sticky="w", pady=5)
        cap_per_pos = ttk.Entry(params_frame, width=10)
        cap_per_pos.grid(row=1, column=1, pady=5, sticky="w")
        cap_per_pos.insert(0, str(self.capital_per_position))

        ttk.Label(params_frame, text="Settings Password:").grid(row=2, column=0, sticky="w", pady=5)
        new_pwd = ttk.Entry(params_frame, width=10, show="*")
        new_pwd.grid(row=2, column=1, pady=5, sticky="w")
        new_pwd.insert(0, self.settings_password)

        btn_frame = ttk.Frame(settings_win)
        btn_frame.pack(pady=20)
        
        ttk.Button(btn_frame, text="Save & Close", 
                  command=lambda: self._save_all_settings(api_key.get(), client_code.get(), password.get(), 
                                                          totp_secret.get(), max_pos.get(), cap_per_pos.get(), 
                                                          new_pwd.get(), settings_win)).pack(side="left", padx=5)
        ttk.Button(btn_frame, text="Cancel", command=settings_win.destroy).pack(side="left", padx=5)

    def _save_all_settings(self, api_key, client_code, password, totp_secret, max_pos, cap_per_pos, new_pwd, win):
        """Save all settings including trading parameters"""
        try:
            success, msg = self.provider.set_credentials(api_key, client_code, password, totp_secret)
            
            self.max_positions = int(max_pos)
            self.capital_per_position = int(cap_per_pos)
            self.settings_password = new_pwd
            
            if success:
                messagebox.showinfo("Saved", "All settings saved successfully!")
                win.destroy()
            else:
                messagebox.showerror("Error", msg)
        except ValueError:
            messagebox.showerror("Error", "Invalid trading parameters. Use numbers only.")

    def _toggle_connect(self):
        if self.provider.is_connected:
            success, msg = self.provider.logout()
            self.set_connection_status(False, live=not self.paper_mode)
            messagebox.showinfo("Logged Out", msg)
        else:
            if not self.provider.api_key:
                messagebox.showwarning("No Credentials", "Please set credentials in Settings first")
                return
            
            success, msg = self.provider.login()
            if success:
                self.set_connection_status(True, live=not self.paper_mode)
                messagebox.showinfo("Connected", "Successfully logged in")
            else:
                messagebox.showerror("Login Failed", msg)
        
        self._refresh_dashboard()

    def _refresh_dashboard(self):
        """✅ FIXED: Refresh dashboard - NON-BLOCKING"""
        def fetch_data():
            provider_snap = self.provider.snapshot()
            
            if self.provider.is_connected:
                broker_holdings = self.provider.get_holdings()
                
                if self.paper_mode:
                    paper_holdings = self.paper_trader.holdings_snapshot()
                    holdings_data = {
                        "paper_trading": paper_holdings,
                        "broker_holdings": broker_holdings
                    }
                else:
                    holdings_data = broker_holdings
            else:
                holdings_data = self.paper_trader.holdings_snapshot()
            
            account_name = self.provider.account_name()
            
            if self.provider.is_connected:
                broker_funds = self.provider.get_funds()
                
                if self.paper_mode:
                    paper_margin = self.paper_trader.get_available_margin()
                    broker_cash = broker_funds.get("available_cash", 0) if isinstance(broker_funds, dict) else broker_funds
                    funds_text = f"Paper: ₹{paper_margin:,.2f} | Broker: ₹{broker_cash:,.2f}"
                else:
                    funds_text = f"₹{broker_funds:,.2f}"
            else:
                paper_margin = self.paper_trader.get_available_margin()
                funds_text = f"₹{paper_margin:,.2f}"
            
            return provider_snap, holdings_data, account_name, funds_text
        
        def on_success(result):
            provider_snap, holdings_data, account_name, funds_text = result
            
            self._provider_text.delete("1.0", "end")
            self._provider_text.insert("end", json.dumps(provider_snap, indent=2))
            
            self._holdings_text.delete("1.0", "end")
            self._holdings_text.insert("end", json.dumps(holdings_data, indent=2))
            
            self._account_name.set(account_name)
            self._netcash_text.set(funds_text)
        
        def on_error(error):
            self._provider_text.delete("1.0", "end")
            self._provider_text.insert("end", f"Error: {error}")
        
        # ✅ Execute in background
        ThreadManager.run_async(
            func=fetch_data,
            on_success=on_success,
            on_error=on_error,
            root=self.root
        )
    
    def _refresh_dashboard_data(self):
        """Helper for auto-refresh"""
        self._refresh_dashboard()
        self._refresh_paper_tab()
        self._update_watchlist_display()