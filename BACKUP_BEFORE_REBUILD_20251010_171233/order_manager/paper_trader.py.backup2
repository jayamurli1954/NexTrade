"""
Enhanced Paper Trader with Intraday Short Selling Support
Supports both long and short positions with automatic square-off
"""

from datetime import datetime
import pandas as pd

class PaperTrader:
    """Paper trading system with intraday support and short selling"""
    
    def __init__(self, initial_cash=100000, leverage=5.0, enable_intraday=True, trade_logger=None):
        """
        Initialize paper trader
        
        Args:
            initial_cash: Starting capital
            leverage: Leverage ratio (default 5x)
            enable_intraday: Allow short selling for intraday trades
            trade_logger: Optional logger for trade history
        """
        self.initial_cash = initial_cash
        self.cash = initial_cash
        self.leverage = leverage
        self.enable_intraday = enable_intraday
        self.used_margin = 0
        self.positions = {}  # Current open positions
        self.trade_history = []
        self.trade_logger = trade_logger
        
        print(f"ðŸ’° PaperTrader started with cash â‚¹{self.cash:,.2f} and leverage x{self.leverage}")
        if enable_intraday:
            print("Intraday trading enabled: SHORT SELLING supported")
    
    def get_available_margin(self):
        """Calculate available margin for trading"""
        total_buying_power = self.cash * self.leverage
        available = total_buying_power - self.used_margin
        return max(0, available)
    
    def buy(self, symbol, quantity, price, stoploss=None, target=None):
        """
        Buy (long) position
        
        Args:
            symbol: Stock symbol
            quantity: Number of shares
            price: Entry price
            stoploss: Stop loss price (optional)
            target: Target price (optional)
        
        Returns:
            dict: Order result with success status and message
        """
        return self.execute_order(
            symbol=symbol,
            action='BUY',
            quantity=quantity,
            price=price,
            stoploss=stoploss,
            target=target
        )
    
    def sell(self, symbol, quantity, price, stoploss=None, target=None):
        """
        Sell (short) position - Intraday only
        
        For intraday trading, allows short selling even without existing position.
        Creates a SHORT position that must be squared off by end of day.
        
        Args:
            symbol: Stock symbol
            quantity: Number of shares to short
            price: Entry price
            stoploss: Stop loss price (optional)
            target: Target price (optional)
        
        Returns:
            dict: Order result with success status and message
        """
        if not self.enable_intraday:
            return {
                'success': False,
                'message': 'Short selling not enabled. Set enable_intraday=True'
            }
        
        return self.execute_order(
            symbol=symbol,
            action='SELL',
            quantity=quantity,
            price=price,
            stoploss=stoploss,
            target=target
        )
    
    def execute_order(self, symbol, action, quantity, price, stoploss=None, target=None):
        """
        Execute buy or sell order with margin management
        
        Handles:
        - Long positions (BUY)
        - Short positions (SELL) - intraday only
        - Position reversal (BUY to cover short, SELL to close long)
        """
        
        if quantity <= 0 or price <= 0:
            return {'success': False, 'message': 'Invalid quantity or price'}
        
        position_value = quantity * price
        required_margin = position_value / self.leverage
        
        # Check if this is closing an existing position
        existing_position = self.positions.get(symbol)
        
        if existing_position:
            # Position exists - check if we're closing or reversing
            if existing_position['type'] != action:
                # Closing or reversing position
                if quantity <= existing_position['quantity']:
                    # Closing partial or full position
                    return self._close_position_partial(symbol, quantity, price, action)
                else:
                    # Reverse: Close existing + open opposite
                    close_qty = existing_position['quantity']
                    reverse_qty = quantity - close_qty
                    
                    # Close existing position
                    close_result = self._close_position_partial(symbol, close_qty, price, action)
                    
                    # Open new opposite position
                    new_action = action
                    return self._open_new_position(symbol, new_action, reverse_qty, price, stoploss, target)
            else:
                # Adding to existing position (same direction)
                return self._add_to_position(symbol, quantity, price)
        
        # No existing position - open new position
        return self._open_new_position(symbol, action, quantity, price, stoploss, target)
    
    def _open_new_position(self, symbol, action, quantity, price, stoploss=None, target=None):
        """Open a new position (long or short)"""
        
        position_value = quantity * price
        required_margin = position_value / self.leverage
        available = self.get_available_margin()
        
        if required_margin > available:
            return {
                'success': False,
                'message': f'Insufficient margin. Required: â‚¹{required_margin:,.2f}, Available: â‚¹{available:,.2f}'
            }
        
        # Deduct margin
        self.used_margin += required_margin
        
        # Create position
        position_type = 'LONG' if action == 'BUY' else 'SHORT'
        self.positions[symbol] = {
            'type': action,
            'position_type': position_type,
            'quantity': quantity,
            'entry_price': price,
            'current_price': price,
            'stoploss': stoploss,
            'target': target,
            'margin_used': required_margin,
            'entry_time': datetime.now(),
            'pnl': 0
        }
        
        # Log trade
        self._log_trade(symbol, action, quantity, price, 'ENTRY')
        
        direction = "LONG" if action == 'BUY' else "SHORT"
        return {
            'success': True,
            'message': f'{direction} {quantity} x {symbol} @ â‚¹{price:.2f}',
            'position': self.positions[symbol].copy()
        }
    
    def _add_to_position(self, symbol, quantity, price):
        """Add to existing position (average up/down)"""
        
        pos = self.positions[symbol]
        position_value = quantity * price
        required_margin = position_value / self.leverage
        available = self.get_available_margin()
        
        if required_margin > available:
            return {
                'success': False,
                'message': f'Insufficient margin to add. Required: â‚¹{required_margin:,.2f}'
            }
        
        # Calculate new average price
        total_qty = pos['quantity'] + quantity
        total_value = (pos['quantity'] * pos['entry_price']) + (quantity * price)
        new_avg_price = total_value / total_qty
        
        # Update position
        pos['quantity'] = total_qty
        pos['entry_price'] = new_avg_price
        pos['margin_used'] += required_margin
        self.used_margin += required_margin
        
        return {
            'success': True,
            'message': f'Added {quantity} to {symbol}. New avg: â‚¹{new_avg_price:.2f}',
            'position': pos.copy()
        }
    
    def _close_position_partial(self, symbol, quantity, exit_price, action):
        """Close partial or full position"""
        
        pos = self.positions[symbol]
        
        if quantity > pos['quantity']:
            quantity = pos['quantity']  # Close max available
        
        # Calculate P&L
        if pos['position_type'] == 'LONG':
            pnl = (exit_price - pos['entry_price']) * quantity
        else:  # SHORT
            pnl = (pos['entry_price'] - exit_price) * quantity
        
        # Release margin proportionally
        margin_to_release = (pos['margin_used'] * quantity) / pos['quantity']
        self.used_margin -= margin_to_release
        self.cash += pnl  # Add/subtract P&L
        
        # Log trade
        self._log_trade(symbol, action, quantity, exit_price, 'EXIT', pnl)
        
        # Update or remove position
        if quantity >= pos['quantity']:
            # Full close
            del self.positions[symbol]
            status = 'CLOSED'
        else:
            # Partial close
            pos['quantity'] -= quantity
            pos['margin_used'] -= margin_to_release
            status = 'PARTIAL_CLOSE'
        
        pnl_str = f"â‚¹{pnl:+,.2f}"
        return {
            'success': True,
            'message': f'{status}: {quantity} x {symbol} @ â‚¹{exit_price:.2f}. P&L: {pnl_str}',
            'pnl': pnl,
            'status': status
        }
    
    def update_position(self, symbol, current_price):
        """Update position with current market price and calculate unrealized P&L"""
        
        if symbol not in self.positions:
            return None
        
        pos = self.positions[symbol]
        pos['current_price'] = current_price
        
        # Calculate unrealized P&L
        if pos['position_type'] == 'LONG':
            pos['pnl'] = (current_price - pos['entry_price']) * pos['quantity']
        else:  # SHORT
            pos['pnl'] = (pos['entry_price'] - current_price) * pos['quantity']
        
        return pos
    
    def check_stoploss_target(self, symbol, current_price):
        """
        Check if stop-loss or target is hit
        
        Returns:
            dict: Action to take (None if no action needed)
        """
        if symbol not in self.positions:
            return None
        
        pos = self.positions[symbol]
        
        # Check stop-loss
        if pos['stoploss']:
            if pos['position_type'] == 'LONG' and current_price <= pos['stoploss']:
                return {'action': 'STOP_LOSS', 'price': current_price}
            elif pos['position_type'] == 'SHORT' and current_price >= pos['stoploss']:
                return {'action': 'STOP_LOSS', 'price': current_price}
        
        # Check target
        if pos['target']:
            if pos['position_type'] == 'LONG' and current_price >= pos['target']:
                return {'action': 'TARGET', 'price': current_price}
            elif pos['position_type'] == 'SHORT' and current_price <= pos['target']:
                return {'action': 'TARGET', 'price': current_price}
        
        return None
    
    def square_off_all(self, provider=None):
        """
        Square off all open positions (end of day settlement)
        
        Args:
            provider: Data provider to fetch current prices (optional)
        """
        if not self.positions:
            print("No open positions to square off")
            return
        
        print(f"\nðŸ”„ Squaring off {len(self.positions)} open positions...")
        
        squared_off = []
        for symbol in list(self.positions.keys()):
            pos = self.positions[symbol]
            
            # Get current price
            if provider:
                try:
                    current_price = provider.get_ltp(symbol, 'NSE')
                except:
                    current_price = pos['current_price']
            else:
                current_price = pos['current_price']
            
            # Close position
            exit_action = 'SELL' if pos['type'] == 'BUY' else 'BUY'
            result = self._close_position_partial(
                symbol, 
                pos['quantity'], 
                current_price, 
                exit_action
            )
            
            if result['success']:
                squared_off.append({
                    'symbol': symbol,
                    'pnl': result['pnl'],
                    'price': current_price
                })
                print(f"  âœ“ {symbol}: {result['message']}")
        
        total_pnl = sum(item['pnl'] for item in squared_off)
        print(f"\nðŸ“Š Square-off complete. Total P&L: â‚¹{total_pnl:+,.2f}")
        
        return squared_off
    
    def _log_trade(self, symbol, action, quantity, price, trade_type, pnl=0):
        """Log trade to history"""
        trade = {
            'timestamp': datetime.now(),
            'symbol': symbol,
            'action': action,
            'quantity': quantity,
            'price': price,
            'type': trade_type,
            'pnl': pnl
        }
        self.trade_history.append(trade)
        
        if self.trade_logger:
            try:
                self.trade_logger.log_trade(trade)
            except Exception as e:
                print(f"Trade logging error: {e}")
    
    def get_portfolio_value(self):
        """Calculate total portfolio value including unrealized P&L"""
        unrealized_pnl = sum(pos['pnl'] for pos in self.positions.values())
        return self.cash + unrealized_pnl
    
    def get_positions(self):
        """Get all open positions"""
        return self.positions.copy()
    
    def get_position(self, symbol):
        """Get specific position"""
        return self.positions.get(symbol)
    
    def has_position(self, symbol):
        """Check if position exists"""
        return symbol in self.positions
    
    def get_summary(self):
        """Get trading summary"""
        unrealized_pnl = sum(pos['pnl'] for pos in self.positions.values())
        total_pnl = self.cash - self.initial_cash
        
        return {
            'initial_cash': self.initial_cash,
            'current_cash': self.cash,
            'realized_pnl': total_pnl,
            'unrealized_pnl': unrealized_pnl,
            'portfolio_value': self.get_portfolio_value(),
            'used_margin': self.used_margin,
            'available_margin': self.get_available_margin(),
            'open_positions': len(self.positions),
            'total_trades': len(self.trade_history)
        }
    
    def holdings_snapshot(self):
        """Get current holdings as DataFrame (compatible with UI)"""
        if not self.positions:
            return pd.DataFrame()
        
        holdings = []
        for symbol, pos in self.positions.items():
            holdings.append({
                'symbol': symbol,
                'quantity': pos['quantity'],
                'avg_price': pos['entry_price'],
                'ltp': pos['current_price'],
                'pnl': pos['pnl'],
                'type': pos['position_type']
            })
        
        return pd.DataFrame(holdings)