"""
Enhanced Paper Trader with Auto-Exit & Excel Logging
=====================================================
File: c:\Users\Dell\tradingbot_new\order_manager\paper_trader.py

Features:
1. Intraday auto-exit at 3:15 PM
2. Auto Stop-Loss and Target execution
3. Excel trade logging with P&L tracking
4. Real-time position monitoring
5. Daily trade summary

COMPLETE - Replace your entire paper_trader.py with this file
"""

from datetime import datetime, time
import pandas as pd
import os
import threading
import openpyxl
from openpyxl.styles import Font, PatternFill, Alignment
import logging

logger = logging.getLogger("PaperTrader")


class PaperTrader:
    """
    Paper trading system with:
    - Intraday auto-exit at 3:15 PM
    - Auto SL/Target execution
    - Excel trade logging
    """
    
    def __init__(self, initial_cash=100000, leverage=5.0, enable_intraday=True, trade_logger=None):
        """Initialize paper trader"""
        self.initial_cash = initial_cash
        self.cash = initial_cash
        self.leverage = leverage
        self.enable_intraday = enable_intraday
        self.used_margin = 0
        self.positions = {}
        self.trade_history = []
        self.trade_logger = trade_logger
        
        # Auto-exit settings
        self.market_close_time = time(15, 15)  # Square off at 3:15 PM
        self.auto_exit_enabled = True
        self._exit_thread = None
        self._stop_monitoring = threading.Event()
        
        # Excel logging
        self.excel_file = self._get_excel_filename()
        self._init_excel_file()
        
        logger.info(f"PaperTrader started: Cash ₹{self.cash:,.2f}, Leverage {self.leverage}x")
        logger.info(f"Auto-exit enabled: Square off at {self.market_close_time.strftime('%H:%M')}")
        logger.info(f"Trade log: {self.excel_file}")
        
        # Start monitoring thread
        if self.auto_exit_enabled:
            self._start_monitoring()
    
    def _get_excel_filename(self):
        """Get Excel filename with date"""
        today = datetime.now().strftime('%Y-%m-%d')
        logs_dir = 'logs/trades'
        os.makedirs(logs_dir, exist_ok=True)
        return os.path.join(logs_dir, f'paper_trades_{today}.xlsx')
    
    def _init_excel_file(self):
        """Initialize Excel file with headers"""
        if os.path.exists(self.excel_file):
            return  # File already exists
        
        try:
            wb = openpyxl.Workbook()
            ws = wb.active
            ws.title = "Trades"
            
            # Headers
            headers = [
                'Trade ID', 'Date', 'Time', 'Symbol', 'Action', 'Type',
                'Quantity', 'Entry Price', 'Exit Price', 'Entry Time', 'Exit Time',
                'Target', 'Stop Loss', 'P&L (₹)', 'P&L %', 'Status', 'Exit Reason'
            ]
            
            # Style headers
            header_fill = PatternFill(start_color='4472C4', end_color='4472C4', fill_type='solid')
            header_font = Font(bold=True, color='FFFFFF')
            
            for col_num, header in enumerate(headers, 1):
                cell = ws.cell(row=1, column=col_num)
                cell.value = header
                cell.fill = header_fill
                cell.font = header_font
                cell.alignment = Alignment(horizontal='center')
            
            # Set column widths
            ws.column_dimensions['A'].width = 12  # Trade ID
            ws.column_dimensions['B'].width = 12  # Date
            ws.column_dimensions['C'].width = 10  # Time
            ws.column_dimensions['D'].width = 15  # Symbol
            ws.column_dimensions['E'].width = 8   # Action
            ws.column_dimensions['F'].width = 10  # Type
            ws.column_dimensions['G'].width = 10  # Quantity
            ws.column_dimensions['H'].width = 12  # Entry Price
            ws.column_dimensions['I'].width = 12  # Exit Price
            ws.column_dimensions['J'].width = 10  # Entry Time
            ws.column_dimensions['K'].width = 10  # Exit Time
            ws.column_dimensions['L'].width = 12  # Target
            ws.column_dimensions['M'].width = 12  # Stop Loss
            ws.column_dimensions['N'].width = 12  # P&L
            ws.column_dimensions['O'].width = 10  # P&L %
            ws.column_dimensions['P'].width = 12  # Status
            ws.column_dimensions['Q'].width = 20  # Exit Reason
            
            wb.save(self.excel_file)
            logger.info(f"Created Excel file: {self.excel_file}")
        except Exception as e:
            logger.error(f"Excel init error: {e}")
    
    def _log_trade_to_excel(self, trade_data):
        """Log trade to Excel file"""
        try:
            wb = openpyxl.load_workbook(self.excel_file)
            ws = wb.active
            
            # Find next row
            next_row = ws.max_row + 1
            
            # Write data
            data = [
                trade_data.get('trade_id', ''),
                trade_data.get('date', ''),
                trade_data.get('time', ''),
                trade_data.get('symbol', ''),
                trade_data.get('action', ''),
                trade_data.get('type', ''),
                trade_data.get('quantity', 0),
                trade_data.get('entry_price', 0),
                trade_data.get('exit_price', 0),
                trade_data.get('entry_time', ''),
                trade_data.get('exit_time', ''),
                trade_data.get('target', 0),
                trade_data.get('stoploss', 0),
                trade_data.get('pnl', 0),
                trade_data.get('pnl_pct', 0),
                trade_data.get('status', ''),
                trade_data.get('exit_reason', '')
            ]
            
            for col_num, value in enumerate(data, 1):
                cell = ws.cell(row=next_row, column=col_num)
                cell.value = value
                cell.alignment = Alignment(horizontal='center')
            
            # Color code P&L
            pnl_cell = ws.cell(row=next_row, column=14)
            if trade_data.get('pnl', 0) > 0:
                pnl_cell.font = Font(color='00B050', bold=True)
            elif trade_data.get('pnl', 0) < 0:
                pnl_cell.font = Font(color='FF0000', bold=True)
            
            wb.save(self.excel_file)
            logger.info(f"Trade logged to Excel: {trade_data['symbol']} P&L=₹{trade_data.get('pnl', 0):.2f}")
        except Exception as e:
            logger.error(f"Excel logging error: {e}")
    
    def get_available_margin(self):
        """Calculate available margin"""
        total_buying_power = self.cash * self.leverage
        available = total_buying_power - self.used_margin
        return max(0, available)
    
    def buy(self, symbol, quantity, price, stoploss=None, target=None):
        """Buy (long) position"""
        result = self.execute_order(
            symbol=symbol,
            action='BUY',
            quantity=quantity,
            price=price,
            stoploss=stoploss,
            target=target
        )
        return result['success'], result['message']
    
    def sell(self, symbol, quantity, price, stoploss=None, target=None):
        """Sell position or short sell"""
        result = self.execute_order(
            symbol=symbol,
            action='SELL',
            quantity=quantity,
            price=price,
            stoploss=stoploss,
            target=target
        )
        return result['success'], result['message']
    
    def execute_order(self, symbol, action, quantity, price, stoploss=None, target=None):
        """Execute order with proper logging"""
        if quantity <= 0 or price <= 0:
            return {'success': False, 'message': 'Invalid quantity or price'}
        
        position_value = quantity * price
        required_margin = position_value / self.leverage
        
        existing_position = self.positions.get(symbol)
        
        if existing_position:
            # Closing existing position
            if existing_position['type'] != action:
                if quantity <= existing_position['quantity']:
                    return self._close_position_partial(symbol, quantity, price, action)
                else:
                    # Close and reverse
                    close_qty = existing_position['quantity']
                    self._close_position_partial(symbol, close_qty, price, action)
                    reverse_qty = quantity - close_qty
                    return self._open_new_position(symbol, action, reverse_qty, price, stoploss, target)
            else:
                # Adding to position
                return self._add_to_position(symbol, quantity, price)
        
        # Open new position
        return self._open_new_position(symbol, action, quantity, price, stoploss, target)
    
    def _open_new_position(self, symbol, action, quantity, price, stoploss=None, target=None):
        """Open new position"""
        position_value = quantity * price
        required_margin = position_value / self.leverage
        available = self.get_available_margin()
        
        if required_margin > available:
            return {
                'success': False,
                'message': f'Insufficient margin. Required: ₹{required_margin:,.2f}, Available: ₹{available:,.2f}'
            }
        
        self.used_margin += required_margin
        
        position_type = 'LONG' if action == 'BUY' else 'SHORT'
        trade_id = self._generate_trade_id()
        
        self.positions[symbol] = {
            'trade_id': trade_id,
            'type': action,
            'position_type': position_type,
            'qty': quantity,
            'avg_price': price,
            'current_price': price,
            'stoploss': stoploss,
            'target': target,
            'margin_used': required_margin,
            'entry_time': datetime.now(),
            'pnl': 0
        }
        
        # Log entry
        trade_data = {
            'trade_id': trade_id,
            'date': datetime.now().strftime('%Y-%m-%d'),
            'time': datetime.now().strftime('%H:%M:%S'),
            'symbol': symbol,
            'action': action,
            'type': 'ENTRY',
            'quantity': quantity,
            'entry_price': price,
            'exit_price': 0,
            'entry_time': datetime.now().strftime('%H:%M:%S'),
            'exit_time': '',
            'target': target or 0,
            'stoploss': stoploss or 0,
            'pnl': 0,
            'pnl_pct': 0,
            'status': 'OPEN',
            'exit_reason': ''
        }
        self._log_trade_to_excel(trade_data)
        
        direction = "LONG" if action == 'BUY' else "SHORT"
        logger.info(f"OPENED: {direction} {quantity} x {symbol} @ ₹{price:.2f} [ID: {trade_id}]")
        
        return {
            'success': True,
            'message': f'{direction} {quantity} x {symbol} @ ₹{price:.2f}',
            'position': self.positions[symbol].copy()
        }
    
    def _close_position_partial(self, symbol, quantity, exit_price, action):
        """Close position"""
        pos = self.positions[symbol]
        
        if quantity > pos['qty']:
            quantity = pos['qty']
        
        # Calculate P&L
        if pos['position_type'] == 'LONG':
            pnl = (exit_price - pos['avg_price']) * quantity
        else:
            pnl = (pos['avg_price'] - exit_price) * quantity
        
        pnl_pct = (pnl / (pos['avg_price'] * quantity)) * 100
        
        # Release margin
        margin_to_release = (pos['margin_used'] * quantity) / pos['qty']
        self.used_margin -= margin_to_release
        self.cash += pnl
        
        # Log exit
        exit_reason = 'MANUAL'
        if hasattr(self, '_last_exit_reason'):
            exit_reason = self._last_exit_reason
            delattr(self, '_last_exit_reason')
        
        trade_data = {
            'trade_id': pos['trade_id'],
            'date': datetime.now().strftime('%Y-%m-%d'),
            'time': datetime.now().strftime('%H:%M:%S'),
            'symbol': symbol,
            'action': action,
            'type': 'EXIT',
            'quantity': quantity,
            'entry_price': pos['avg_price'],
            'exit_price': exit_price,
            'entry_time': pos['entry_time'].strftime('%H:%M:%S'),
            'exit_time': datetime.now().strftime('%H:%M:%S'),
            'target': pos.get('target', 0),
            'stoploss': pos.get('stoploss', 0),
            'pnl': pnl,
            'pnl_pct': pnl_pct,
            'status': 'CLOSED',
            'exit_reason': exit_reason
        }
        self._log_trade_to_excel(trade_data)
        
        # Update or remove position
        if quantity >= pos['qty']:
            del self.positions[symbol]
            status = 'CLOSED'
        else:
            pos['qty'] -= quantity
            pos['margin_used'] -= margin_to_release
            status = 'PARTIAL_CLOSE'
        
        pnl_emoji = "✓" if pnl > 0 else "✗"
        logger.info(f"{pnl_emoji} {status}: {quantity} x {symbol} @ ₹{exit_price:.2f} | P&L: ₹{pnl:+,.2f} ({pnl_pct:+.2f}%) | Reason: {exit_reason}")
        
        return {
            'success': True,
            'message': f'{status}: {quantity} x {symbol} @ ₹{exit_price:.2f}. P&L: ₹{pnl:+,.2f} ({pnl_pct:+.2f}%)',
            'pnl': pnl,
            'status': status
        }
    
    def _add_to_position(self, symbol, quantity, price):
        """Add to existing position"""
        pos = self.positions[symbol]
        position_value = quantity * price
        required_margin = position_value / self.leverage
        available = self.get_available_margin()
        
        if required_margin > available:
            return {
                'success': False,
                'message': f'Insufficient margin to add. Required: ₹{required_margin:,.2f}'
            }
        
        total_qty = pos['qty'] + quantity
        total_value = (pos['qty'] * pos['avg_price']) + (quantity * price)
        new_avg_price = total_value / total_qty
        
        pos['qty'] = total_qty
        pos['avg_price'] = new_avg_price
        pos['margin_used'] += required_margin
        self.used_margin += required_margin
        
        return {
            'success': True,
            'message': f'Added {quantity} to {symbol}. New avg: ₹{new_avg_price:.2f}',
            'position': pos.copy()
        }
    
    def _generate_trade_id(self):
        """Generate unique trade ID"""
        return f"T{datetime.now().strftime('%Y%m%d%H%M%S')}"
    
    def update_position(self, symbol, current_price):
        """Update position with current price"""
        if symbol not in self.positions:
            return None
        
        pos = self.positions[symbol]
        pos['current_price'] = current_price
        
        if pos['position_type'] == 'LONG':
            pos['pnl'] = (current_price - pos['avg_price']) * pos['qty']
        else:
            pos['pnl'] = (pos['avg_price'] - current_price) * pos['qty']
        
        return pos
    
    def check_and_execute_sl_target(self, symbol, current_price):
        """Check and auto-execute SL/Target"""
        if symbol not in self.positions:
            return None
        
        pos = self.positions[symbol]
        
        # Check stop-loss
        if pos.get('stoploss'):
            if pos['position_type'] == 'LONG' and current_price <= pos['stoploss']:
                self._last_exit_reason = 'STOP_LOSS'
                exit_action = 'SELL' if pos['type'] == 'BUY' else 'BUY'
                result = self._close_position_partial(symbol, pos['qty'], current_price, exit_action)
                logger.warning(f"STOP-LOSS HIT: {symbol} @ ₹{current_price:.2f}")
                return {'action': 'STOP_LOSS', 'result': result}
            
            elif pos['position_type'] == 'SHORT' and current_price >= pos['stoploss']:
                self._last_exit_reason = 'STOP_LOSS'
                exit_action = 'SELL' if pos['type'] == 'BUY' else 'BUY'
                result = self._close_position_partial(symbol, pos['qty'], current_price, exit_action)
                logger.warning(f"STOP-LOSS HIT: {symbol} @ ₹{current_price:.2f}")
                return {'action': 'STOP_LOSS', 'result': result}
        
        # Check target
        if pos.get('target'):
            if pos['position_type'] == 'LONG' and current_price >= pos['target']:
                self._last_exit_reason = 'TARGET'
                exit_action = 'SELL' if pos['type'] == 'BUY' else 'BUY'
                result = self._close_position_partial(symbol, pos['qty'], current_price, exit_action)
                logger.info(f"TARGET REACHED: {symbol} @ ₹{current_price:.2f}")
                return {'action': 'TARGET', 'result': result}
            
            elif pos['position_type'] == 'SHORT' and current_price <= pos['target']:
                self._last_exit_reason = 'TARGET'
                exit_action = 'SELL' if pos['type'] == 'BUY' else 'BUY'
                result = self._close_position_partial(symbol, pos['qty'], current_price, exit_action)
                logger.info(f"TARGET REACHED: {symbol} @ ₹{current_price:.2f}")
                return {'action': 'TARGET', 'result': result}
        
        return None
    
    def _start_monitoring(self):
        """Start monitoring thread for auto-exit"""
        self._stop_monitoring.clear()
        self._exit_thread = threading.Thread(target=self._monitor_positions, daemon=True)
        self._exit_thread.start()
        logger.info("Position monitoring started")
    
    def _monitor_positions(self):
        """Monitor positions for auto-exit at 3:15 PM"""
        import time as time_module
        
        while not self._stop_monitoring.is_set():
            try:
                now = datetime.now().time()
                
                # Check if it's 3:15 PM or later
                if now >= self.market_close_time and self.positions:
                    logger.warning(f"AUTO-EXIT TRIGGERED at {now.strftime('%H:%M:%S')}")
                    self._auto_square_off_all()
                    break  # Stop monitoring after square off
                
                # Sleep for 30 seconds before next check
                time_module.sleep(30)
                
            except Exception as e:
                logger.error(f"Monitoring error: {e}")
                time_module.sleep(60)
    
    def _auto_square_off_all(self):
        """Auto square off all positions at market close"""
        if not self.positions:
            return
        
        logger.warning(f"FORCE SQUARE OFF: Closing {len(self.positions)} open positions at 3:15 PM")
        
        squared_off = []
        for symbol in list(self.positions.keys()):
            pos = self.positions[symbol]
            current_price = pos['current_price']
            
            self._last_exit_reason = 'AUTO_EXIT_3:15PM'
            exit_action = 'SELL' if pos['type'] == 'BUY' else 'BUY'
            
            result = self._close_position_partial(
                symbol, 
                pos['qty'], 
                current_price, 
                exit_action
            )
            
            if result['success']:
                squared_off.append({
                    'symbol': symbol,
                    'pnl': result['pnl'],
                    'price': current_price
                })
        
        total_pnl = sum(item['pnl'] for item in squared_off)
        logger.info(f"AUTO SQUARE-OFF COMPLETE: Total P&L = ₹{total_pnl:+,.2f}")
        
        # Print summary to console
        print("\n" + "="*80)
        print("  AUTO SQUARE-OFF EXECUTED AT 3:15 PM")
        print("="*80)
        for item in squared_off:
            pnl_sign = "+" if item['pnl'] >= 0 else ""
            print(f"  {item['symbol']:12} @ ₹{item['price']:8.2f}  |  P&L: {pnl_sign}₹{item['pnl']:,.2f}")
        print("="*80)
        print(f"  TOTAL P&L: {'+' if total_pnl >= 0 else ''}₹{total_pnl:,.2f}")
        print("="*80 + "\n")
        
        return squared_off
    
    def square_off_all(self, provider=None):
        """Manual square off all positions"""
        if not self.positions:
            logger.info("No open positions to square off")
            return []
        
        logger.info(f"Manual square off: {len(self.positions)} positions")
        
        squared_off = []
        for symbol in list(self.positions.keys()):
            pos = self.positions[symbol]
            
            # Get current price from provider if available
            if provider:
                try:
                    current_price = provider.get_ltp(symbol, 'NSE')
                except:
                    current_price = pos['current_price']
            else:
                current_price = pos['current_price']
            
            self._last_exit_reason = 'MANUAL_SQUARE_OFF'
            exit_action = 'SELL' if pos['type'] == 'BUY' else 'BUY'
            
            result = self._close_position_partial(
                symbol, 
                pos['qty'], 
                current_price, 
                exit_action
            )
            
            if result['success']:
                squared_off.append({
                    'symbol': symbol,
                    'pnl': result['pnl'],
                    'price': current_price
                })
        
        total_pnl = sum(item['pnl'] for item in squared_off)
        logger.info(f"Manual square-off complete. Total P&L: ₹{total_pnl:+,.2f}")
        
        return squared_off
    
    def get_portfolio_value(self):
        """Calculate total portfolio value"""
        unrealized_pnl = sum(pos['pnl'] for pos in self.positions.values())
        return self.cash + unrealized_pnl
    
    def get_positions(self):
        """Get all open positions"""
        return self.positions.copy()
    
    def get_position(self, symbol):
        """Get specific position"""
        return self.positions.get(symbol)
    
    def has_position(self, symbol):
        """Check if position exists"""
        return symbol in self.positions
    
    def get_summary(self):
        """Get trading summary"""
        unrealized_pnl = sum(pos['pnl'] for pos in self.positions.values())
        total_pnl = self.cash - self.initial_cash
        
        return {
            'initial_cash': self.initial_cash,
            'current_cash': self.cash,
            'realized_pnl': total_pnl,
            'unrealized_pnl': unrealized_pnl,
            'portfolio_value': self.get_portfolio_value(),
            'used_margin': self.used_margin,
            'available_margin': self.get_available_margin(),
            'open_positions': len(self.positions),
            'total_trades': len(self.trade_history)
        }
    
    def holdings_snapshot(self):
        """Get holdings snapshot for UI"""
        summary = self.get_summary()
        
        return {
            'total_positions': len(self.positions),
            'cash': self.cash,
            'used_margin': self.used_margin,
            'available_margin': self.get_available_margin(),
            'unrealized_pnl': summary['unrealized_pnl'],
            'portfolio_value': summary['portfolio_value'],
            'positions': {symbol: pos for symbol, pos in self.positions.items()}
        }
    
    def get_daily_summary_from_excel(self):
        """Get daily summary from Excel"""
        try:
            if not os.path.exists(self.excel_file):
                return {
                    'total_trades': 0,
                    'winning_trades': 0,
                    'losing_trades': 0,
                    'total_pnl': 0,
                    'win_rate': 0
                }
            
            df = pd.read_excel(self.excel_file)
            
            # Filter only EXIT trades
            exits = df[df['Type'] == 'EXIT']
            
            total_trades = len(exits)
            winning_trades = len(exits[exits['P&L (₹)'] > 0])
            losing_trades = len(exits[exits['P&L (₹)'] < 0])
            total_pnl = exits['P&L (₹)'].sum()
            win_rate = (winning_trades / total_trades * 100) if total_trades > 0 else 0
            
            return {
                'total_trades': total_trades,
                'winning_trades': winning_trades,
                'losing_trades': losing_trades,
                'total_pnl': total_pnl,
                'win_rate': win_rate,
                'avg_win': exits[exits['P&L (₹)'] > 0]['P&L (₹)'].mean() if winning_trades > 0 else 0,
                'avg_loss': exits[exits['P&L (₹)'] < 0]['P&L (₹)'].mean() if losing_trades > 0 else 0
            }
        except Exception as e:
            logger.error(f"Excel summary error: {e}")
            return {
                'total_trades': 0,
                'winning_trades': 0,
                'losing_trades': 0,
                'total_pnl': 0,
                'win_rate': 0
            }
    
    def print_daily_summary(self):
        """Print daily summary to console"""
        summary = self.get_daily_summary_from_excel()
        
        print("\n" + "="*80)
        print("  DAILY TRADING SUMMARY")
        print("="*80)
        print(f"  Total Trades     : {summary['total_trades']}")
        print(f"  Winning Trades   : {summary['winning_trades']}")
        print(f"  Losing Trades    : {summary['losing_trades']}")
        print(f"  Win Rate         : {summary['win_rate']:.2f}%")
        print(f"  Total P&L        : ₹{summary['total_pnl']:+,.2f}")
        if summary['total_trades'] > 0:
            print(f"  Avg Win          : ₹{summary.get('avg_win', 0):+,.2f}")
            print(f"  Avg Loss         : ₹{summary.get('avg_loss', 0):+,.2f}")
        print("="*80)
        print(f"  Excel Report: {self.excel_file}")
        print("="*80 + "\n")
    
    def stop(self):
        """Stop monitoring thread"""
        self._stop_monitoring.set()
        if self._exit_thread:
            self._exit_thread.join(timeout=2)
        logger.info("Paper trader stopped")
    
    def __del__(self):
        """Cleanup on deletion"""
        self.stop()